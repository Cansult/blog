---
title: '翻车笔记 ZKY 学长的杂题2 [杂题, 清奇脑回路]'
tags:
  - 杂题
  - 清奇脑回路
categories: 翻车笔记
mathjax: true
abbrlink: 37019
date: 2019-02-21 17:38:34
layout:
---



第一篇文章莫名就1w字了

辣鸡Typora打开已经有点卡了...于是新开一个...

计数器: 

## <font color=#b11d23>2</font>

<!--more-->

### [种树](https://lydsy.com/JudgeOnline/problem.php?id=2151)

[这类问题的合集](https://cansult.ga/18992.html)

### [[NOI2010]超级钢琴](https://lydsy.com/JudgeOnline/problem.php?id=2006)

这个题和上一个一脉相承啊... = =

这个限制不用合并区间 也就不用搞链表了 挺舒服的

然而写着写着发现还有区间重复的问题... = =

去参拜了一发题解才发现还要记录当前的右端点是从哪个区间里选出来的 然后就不会重复了... = =

```cpp
/**************************************************************
    Problem: 2006
    User: Cansult
    Language: C++
    Result: Accepted
    Time:4484 ms
    Memory:82800 kb
****************************************************************/
 
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <algorithm>
#include <queue>
#define LL long long
#define int LL 
#define MAXN (500000 + 5)
#define LS(dq) ((dq) << 1)
#define RS(dq) (LS(dq) | 1)
using namespace std;
struct node {
    int le, ri, zh;
} b[MAXN << 2];
struct num {
    int le, ri, zh, lil, lir;
    num() {}
    num(int l, int r, int z, int ll, int rr): le(l), ri(r), zh(z), lil(ll), lir(rr) {}
};
struct cmp {
    bool operator () (const num x, const num y) { return x.zh < y.zh; }
}; 
int n, k, L, R, fr[MAXN], ans;
priority_queue<num, vector<num>, cmp> q;
void js(int dq, int le, int ri) {
    b[dq].le = le, b[dq].ri = ri, b[dq].zh = le;
    if (le == ri) return ;
    int mi = (le + ri) >> 1;
    js(LS(dq), le, mi), js(RS(dq), mi + 1, ri);
    b[dq].zh = (fr[b[LS(dq)].zh] > fr[b[RS(dq)].zh]) ? b[LS(dq)].zh : b[RS(dq)].zh;
}
int cx(int dq, int le, int ri) {
    if (le > ri || le < 1 || ri > n) return n + 1;
    if (b[dq].le == le && b[dq].ri == ri) return b[dq].zh;
    int mi = (b[dq].le + b[dq].ri) >> 1;
    if (le > mi) return cx(RS(dq), le, ri);
    else if (ri <= mi) return cx(LS(dq), le, ri);
    else {
        int ls = cx(LS(dq), le, mi), rs = cx(RS(dq), mi + 1, ri);
        return (fr[ls] > fr[rs]) ? ls : rs;
    }
}
main() {
    scanf("%lld%lld%lld%lld", &n, &k, &L, &R);
    for (int i = 1, dqx; i <= n; i++) scanf("%lld", &dqx), fr[i] = fr[i - 1] + dqx;
    js(1, 1, n);
    for (int i = 1, maxi; i + L - 1 <= n; i++) maxi = cx(1, i + L - 1, min(n, i + R - 1)), q.push(num(i, maxi, fr[maxi] - fr[i - 1], i + L - 1, i + R - 1));
    for (int i = 1, maxi; i <= k; i++) {
        num dq = q.top();
        q.pop();
        ans += dq.zh;
        maxi = cx(1, max(dq.lil, dq.le + L - 1), min(dq.lir, dq.ri - 1));
        if (maxi >= 1 && maxi <= n) q.push(num(dq.le, maxi, fr[maxi] - fr[dq.le - 1], max(dq.lil, dq.le + L - 1), min(dq.lir, dq.ri - 1)));
        maxi = cx(1, max(dq.lil, dq.ri + 1), min(n, min(dq.lir, dq.le + R - 1)));
        if (maxi >= 1 && maxi <= n) q.push(num(dq.le, maxi, fr[maxi] - fr[dq.le - 1], max(dq.lil, dq.ri + 1), min(dq.lir, dq.le + R - 1)));
    }
    printf("%lld", ans);
    return 0;
}
```



By 准备退役旅游的 Cansult
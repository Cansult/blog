---
title: '新的翻车集 [翻车]'
tags:
  - 翻车
categories: 翻车笔记
mathjax: true
abbrlink: 22925
date: 8102-01-01 00:00:00
layout:
---





noip出分了之后悲痛欲绝励志退役然后就把blog全删掉了???

后来还是想再苟一苟???

于是有了新的翻车集...

<!--more-->

1. ST表的边界和查询的时候应该返回`max(st[l][jg - 1], st[r - (1 << (jg - 1)) + 1][jg - 1]);`(右边要`+1`避免遗漏)
2. 关流同步 + `cin.tie(NULL)` 还是不如快读...**关了流同步文件操作会GG**
3. 高精度进位的条件是`<=`...高精去前导`0`的时候不要忘记只有一位数`0`的情况...
4. tarjan 求强连通分量是单向边...
5. 炸空间...算好空间比算好时间更加重要
6. 开栈: `-O2 -Wshadow -Wunused -g -Wall -Wextra -Wl,--stack=67108864`
7. 防炸`LL`先除后乘, 防炸精度先乘后除
8. 求最大的$ans$没有取$\max$????
9. **线段树没有`push_down`就递归了???~~(这两个都是特别困的时候犯的错误)~~, 又犯了.................**
10. 初始化数组的时候, 数组大小是`MAXN`, 结果初始化的时候循环到了`MAXN` ...
11. **有了思路就去写代码...甚至没有去手玩样例...**
12. 如果这么写$\max$函数: `#define max(a, b) ((a) > (b) ? (a) :(b))`, 然后你又将函数的返回值当成变量放在了`max()`里, 而你的函数又恰好会对某些全局的值造成影响, 你就会发现你的值被改变了两次...$\to \mathrm {GG}(WA+TLE)$
13. `lazy`标记...覆盖是用`=`, 区间加是`+=`...
14. 数组代表的意思自己给忘了...记得加点注释吧
15. **树链剖分`while`里比较的是`if (ta[ta[x].top].deep < ta[ta[y].top].deep)`, 而不是`if (ta[x].deep > ta[y].deep)`, (怎么感觉最近犯的错误越来越低级了...**
16. `(b[dq].le + b[dq].ri) >> 1`写成`(le + ri) >> 1`$\to \mathrm{GG}$(爆栈) (怎么感觉最近犯的错误越来越低级了...
17. `priority_queue`中的`cmp`如果是仿函数别忘了里面的大小比较是正好相反的...
18. 反向边的编号计算应该是这样: `#define bh(x, i) ((MAXN) * (i) + (x))`, 而不是`#define bh(x, i) ((MAXK) * (i) + (x))`, 即注意每一次都是复制了一整张图...
19. 谨慎用宏...改加的不该加的括号都想清楚了...能加就加上吧...反着你也背不过运算优先级...
20. SA...居然能把`last = i`写成`i = last`...SA打的还是不是很熟...
21. SA把`sa[tong[fir[i]]--] = i`写成了`sa[tong[fir[i]--]]`...也许我应该在中括号之间加个空格啥的...`fir`数组你减个\*\*啊...
22. SPFA...`inq[dq]`忘了置成`false`...还有`dq = q.front()`后忘了`q.pop()`...我真是越来越傻逼了...
23. $exgcd$ $ax + by = 1$最后$x$加上的是$b / \gcd$...不是$y / \gcd$...你求出的是$a, b$的$\gcd$...用$y$除是要闹哪样...果然我越来越傻逼了...
24. $exgcd$ 最后是$y -= a / b * x$而不是什么奇奇怪怪的东西...过了这么长时间背的还是不熟啊...~~主要是不想做数论题~~
25. 找负环的时候别忘了在`dfs`回溯的时候把当前节点的`vis`标记置为`false`, 防止横叉边被误判成负环
26. 写错变量名...
27. 数组把`MAXN * 32`写成`MAXN << 32`...而且编译完了测样例是WA而不是RE...
28. 函数传参数的时候忘改成`LL`....
29. 输出忘了`%lld`...
30. `dinic`的`bfs()`忘记写`dis[s] = 1`...
31. `INF`赋小了...这个需要仔细算一下
32. `m`和`n`写反...或者没改全...比如求平均数除错了...
33. 树剖: `x = ta[ta[x].top].fa`...而不是`x = ta[x].top`
34. codeblocks用中文工程名...还怀疑codeblocks不能调试...
35. `for (int i = g[dq]; ~i; i = b[i].next)`没有`memset(g, -1, sizeof(g));`
36. ST表: `if (le + (t << 1) - 1 <= n)` 以及 `if (le + (1 << t) <= n)`...直接给我$RE$成零分了...
37. 进行一个类似`fr[i] = fr[i - 1] + a[i] * i`的预处理时(只把`fr[]`设为`LL`了)没有把`a[]`开成`LL`, 这样在进行乘法的时候就已经炸了...
38. 分块的时候最后一个右边界没有和$n$取$min$, 然后就凉了
39. 进行会爆`int`的位运算, 写成了`1 << i`, 应该是`1ll << i`
40. 在有多种边的图中, 跑$kruskal$, 把存这一个边数组排了序, 结果$kruskal$的时候加了另一种边...
41. 数组不要开小, 尤其主席树...不要尝试算准空间...往大里开就完事了
42. 排序时注意相等的情况应该让哪个排在前面
43. 树状数组`for(int i = x; i <= n; i += lowbit(i))`注意判断是否传入的是$0$ 
44. $tarjan$缩点的时候要判断两个点是否属于一个连通分量
45. $tarjan$缩点之后可能会出现重边, 注意对答案的影响
46. 倍增求LCA的时候, 在两个点跳到一个深度的时候记得看看这两个点是否已经相等了
47. 网络流题目给的邻接矩阵, 建图的时候忘了加反向边
48. 带取膜的前缀和, 求区间和的时候忘了处理负数
49. 忘记输出答案 以为$RE$了...
50. `int`的范围是`2e9`...不要想当然的读入用`int`然后溢出
51. 试除小于根号质数来分解质因数的时候别忘了除完最后可能不为`1`
52. 倍增没有给`lgn`赋值...居然还能过不少点真是太真实了...
53. 没有注意到可能图不是连通图...
54. SAM没有`init()`
55. 分块忘记处理询问区间包含的数很少, 没有包含任何一个块的情况
56. $0$是自然数
57. 按秩合并的并查集在合并的时候没有判断他们两个是否已经属于一个并查集了 (还有合并可并对的时候)
58. 全局的结构体似乎里面的值也不一定都是`0`? 还是需要初始化一下的啊
59. 注意特殊情况的特判
60. 多组数据 一组数据读到一半就判断出答案了 然后就直接跳到了下一组 导致下一组的读入加上了这一组未读入的部分
61. 线性基没有判断要插入的数当前这一位是不是`1`...
62. 树刨忘记写最后他们在一条重链上的情况了 = =
63. 据说开场看题的时候要先把一眼分标出来? 
64. AC自动机做`fail`边的时候忘了`push`了...